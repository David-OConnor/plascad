//! [BioPython code](https://github.com/biopython/biopython/blob/master/Bio/SeqIO/AbiIO.py)

use std::{fmt::Display, io, io::ErrorKind};

#[derive(Clone, Copy, PartialEq)]
enum TagSeqRecord {
    SampleWell,
    Dye,
    Polymer,
    MachineModel,
}
// todo: Tag to string rep?
impl TagSeqRecord {
    fn from_str(inp: &str) -> io::Result<Self> {
        match inp {
            "TUBE1" => Ok(Self::SampleWell),
            "DySN1" => Ok(Self::SampleWell),
            "GTyp1" => Ok(Self::SampleWell),
            "MODL1" => Ok(Self::SampleWell),
            _ => Err(io::Error::new(ErrorKind::InvalidData, "Invalid tag string")),
        }
    }
}

#[derive(Clone, Copy, PartialEq)]
enum GeneralTag {
    Apfn2,
    Apxv1,
    Aprn1,
    Aprv1,
    Aprx1,
    Cmnt1,
    Ctid1,
    Ctnm1,
    Cttl1,
    Cpep1,
    Data1,
    Data2,
    Data3,
    Data4,
    Data5,
    Data6,
    Data7,
    Data8,
    Data9,
    Data10,
    Data11,
    Data12,
    Dsam1,
    Dysn1,
    DyeNum1,
    DyeN1,
    DyeN2,
    DyeN3,
    DyeN4,
    DyeW1,
    DyeW2,
    DyeW3,
    DyeW4,
    Epvt1,
    Evnt1,
    Evnt2,
    Evnt3,
    Evnt4,
    Fwo1,
    Gtyp1,
    Insc1,
    Invt1,
    Lane1,
    Lims1,
    Lntd1,
    Lsrp1,
    Mchn1,
    Modf1,
    Modl1,
    Navg1,
    Nlne1,
    Ofsc1,
    Ovri1,
    Ovri2,
    Ovri3,
    Ovri4,
    Ovrv1,
    Ovrv2,
    Ovrv3,
    Ovrv4,
    Pdmf1,
    Rmxv1,
    Rmdn1,
    Rmdx1,
    Rprn1,
    Rprv1,
    Rund1,
    Rund2,
    Rund3,
    Rund4,
    Runt1,
    Runt2,
    Runt3,
    Runt4,
    Rate1,
    Runn1,
    Scan1,
    Smed1,
    Smlt1,
    Smpl1,
    Sver1,
    Sver3,
    Satd1,
    Scal1,
    Tube1,
    Tmpr1,
    User1,
}

impl GeneralTag {
    fn from_str(inp: &str) -> io::Result<Self> {
        match inp {
            "APFN2" => Ok(Self::Apfn2),
            "APXV1" => Ok(Self::Apxv1),
            "APrN1" => Ok(Self::Aprn1),
            "APrV1" => Ok(Self::Aprv1),
            "APrX1" => Ok(Self::Aprx1),
            "CMNT1" => Ok(Self::Cmnt1),
            "CTID1" => Ok(Self::Ctid1),
            "CTNM1" => Ok(Self::Ctnm1),
            "CTTL1" => Ok(Self::Cttl1),
            "CpEP1" => Ok(Self::Cpep1),
            "DATA1" => Ok(Self::Data1),
            "DATA2" => Ok(Self::Data2),
            "DATA3" => Ok(Self::Data3),
            "DATA4" => Ok(Self::Data4),
            "DATA5" => Ok(Self::Data5),
            "DATA6" => Ok(Self::Data6),
            "DATA7" => Ok(Self::Data7),
            "DATA8" => Ok(Self::Data8),
            "DATA9" => Ok(Self::Data9),
            "DATA10" => Ok(Self::Data10),
            "DATA11" => Ok(Self::Data11),
            "DATA12" => Ok(Self::Data12),
            "DSam1" => Ok(Self::Dsam1),
            "DySN1" => Ok(Self::Dysn1),
            "Dye#1" => Ok(Self::DyeNum1),
            "DyeN1" => Ok(Self::DyeN1),
            "DyeN2" => Ok(Self::DyeN2),
            "DyeN3" => Ok(Self::DyeN3),
            "DyeN4" => Ok(Self::DyeN4),
            "DyeW1" => Ok(Self::DyeW1),
            "DyeW2" => Ok(Self::DyeW2),
            "DyeW3" => Ok(Self::DyeW3),
            "DyeW4" => Ok(Self::DyeW4),
            "EPVt1" => Ok(Self::Epvt1),
            "EVNT1" => Ok(Self::Evnt1),
            "EVNT2" => Ok(Self::Evnt2),
            "EVNT3" => Ok(Self::Evnt3),
            "EVNT4" => Ok(Self::Evnt4),
            "FWO_1" => Ok(Self::Fwo1),
            "GTyp1" => Ok(Self::Gtyp1),
            "InSc1" => Ok(Self::Insc1),
            "InVt1" => Ok(Self::Invt1),
            "LANE1" => Ok(Self::Lane1),
            "LIMS1" => Ok(Self::Lims1),
            "LNTD1" => Ok(Self::Lntd1),
            "LsrP1" => Ok(Self::Lsrp1),
            "MCHN1" => Ok(Self::Mchn1),
            "MODF1" => Ok(Self::Modf1),
            "MODL1" => Ok(Self::Modl1),
            "NAVG1" => Ok(Self::Navg1),
            "NLNE1" => Ok(Self::Nlne1),
            "OfSc1" => Ok(Self::Ofsc1),
            "OvrI1" => Ok(Self::Ovri1),
            "OvrI2" => Ok(Self::Ovri2),
            "OvrI3" => Ok(Self::Ovri3),
            "OvrI4" => Ok(Self::Ovri4),
            "OvrV1" => Ok(Self::Ovrv1),
            "OvrV2" => Ok(Self::Ovrv2),
            "OvrV3" => Ok(Self::Ovrv3),
            "OvrV4" => Ok(Self::Ovrv4),
            "PDMF1" => Ok(Self::Pdmf1),
            "RMXV1" => Ok(Self::Rmxv1),
            "RMdN1" => Ok(Self::Rmdn1),
            "RMdX1" => Ok(Self::Rmdx1),
            "RPrN1" => Ok(Self::Rprn1),
            "RPrV1" => Ok(Self::Rprv1),
            "RUND1" => Ok(Self::Rund1),
            "RUND2" => Ok(Self::Rund2),
            "RUND3" => Ok(Self::Rund3),
            "RUND4" => Ok(Self::Rund4),
            "RUNT1" => Ok(Self::Runt1),
            "RUNT2" => Ok(Self::Runt2),
            "RUNT3" => Ok(Self::Runt3),
            "RUNT4" => Ok(Self::Runt4),
            "Rate1" => Ok(Self::Rate1),
            "RunN1" => Ok(Self::Runn1),
            "SCAN1" => Ok(Self::Scan1),
            "SMED1" => Ok(Self::Smed1),
            "SMLt1" => Ok(Self::Smlt1),
            "SMPL1" => Ok(Self::Smpl1),
            "SVER1" => Ok(Self::Sver1),
            "SVER3" => Ok(Self::Sver3),
            "Satd1" => Ok(Self::Satd1),
            "Scal1" => Ok(Self::Scal1),
            "TUBE1" => Ok(Self::Tube1),
            "Tmpr1" => Ok(Self::Tmpr1),
            "User1" => Ok(Self::User1),
            _ => Err(io::Error::new(
                ErrorKind::InvalidData,
                format!("Invalid tag string: {}", inp),
            )),
        }
    }
}

// impl ToString for GeneralTag {
//     fn to_string(&self) -> String {
//         match self {
//             Self::Apfn2 => "Sequencing Analysis parameters file name",
//

#[derive(Clone, Copy, PartialEq)]
enum Abi3130Tag {
    CtoW1,
    HcfG1,
    HcfG2,
    HcfG3,
    HcfG4,
    RmdVa1,
}

impl Abi3130Tag {
    fn from_str(inp: &str) -> io::Result<Self> {
        match inp {
            "CTOw1" => Ok(Self::CtoW1),
            "HCFG1" => Ok(Self::HcfG1),
            "HCFG2" => Ok(Self::HcfG2),
            "HCFG3" => Ok(Self::HcfG3),
            "HCFG4" => Ok(Self::HcfG4),
            "RMdVa1" => Ok(Self::RmdVa1),
            _ => Err(io::Error::new(
                ErrorKind::InvalidData,
                format!("Invalid tag string: {}", inp),
            )),
        }
    }
}

impl Display for Abi3130Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let str = match self {
            Self::CtoW1 => "Container owner",
            Self::HcfG1 => "Instrument Class",
            Self::HcfG2 => "Instrument Family",
            Self::HcfG3 => "Official Instrument Name",
            Self::HcfG4 => "Instrument Parameters",
            Self::RmdVa1 => "Run Module version",
        }
        .to_string();
        write!(f, "{}", str)
    }
}

#[derive(Clone, Copy, PartialEq)]
enum Abi3530Tag {
    Aact1,
    Abed1,
    Abid1,
    Ablt1,
    Abrn1,
    Abtp1,
    Aept1,
    Aept2,
    Apcn1,
    Artn1,
    Aspf1,
    Aspt1,
    Aspt2,
    Audt2,
    Avld1,
    Ambt1,
    Asyc1,
    Asyn1,
    Asyv1,
    B1pt1,
    B1pt2,
    Bcts1,
    Bcrn1,
    Bcrs1,
    Bcrs2,
    Caed1,
    Calt1,
    Carn1,
    Casn1,
    Cbed1,
    Cbid1,
    Cblt1,
    Cbrn1,
    Cbtp1,
    Clrg1,
    Clrg2,
    Crln1,
    Crln2,
    Ctow1,
    Cksm1,
    Dcev1,
    Dcht1,
    Doev1,
    Esig2,
    Ftab1,
    Fvoc1,
    Feat1,
    Hcfg1,
    Hcfg2,
    Hcfg3,
    Hcfg4,
    Injn1,
    Last1,
    Nois1,
    P1am1,
    P1rl1,
    P1wd1,
    P2am1,
    P2ba1,
    P2rl1,
    Pbas1,
    Pbas2,
    Pcon1,
    Pcon2,
    Pdmf2,
    Ploc1,
    Ploc2,
    Prjt1,
    Proj4,
    Psze1,
    Ptyp1,
    Pusc1,
    Qv201,
    Qv202,
    Qcpa1,
    Qcrn1,
    Qcrs1,
    Qcrs2,
    Rgow1,
    Rinj1,
    Rnmf1,
    Revc1,
    Runn1,
    Sn1,
    Smid1,
    Smrn1,
    Spac1,
    Spac2,
    Spac3,
    Spec1,
    Sver2,
    Sver4,
    Scpa1,
    Scst1,
    Spen1,
    Trpa1,
    Trsc1,
    Trsc2,
    Phar1,
    Phch1,
    Phdy1,
    Phql1,
    Phtr1,
    Phtr2,
}

impl Abi3530Tag {
    fn from_str(inp: &str) -> io::Result<Self> {
        match inp {
            "AAct1" => Ok(Self::Aact1),
            "ABED1" => Ok(Self::Abed1),
            "ABID1" => Ok(Self::Abid1),
            "ABLt1" => Ok(Self::Ablt1),
            "ABRn1" => Ok(Self::Abrn1),
            "ABTp1" => Ok(Self::Abtp1),
            "AEPt1" => Ok(Self::Aept1),
            "AEPt2" => Ok(Self::Aept2),
            "APCN1" => Ok(Self::Apcn1),
            "ARTN1" => Ok(Self::Artn1),
            "ASPF1" => Ok(Self::Aspf1),
            "ASPt1" => Ok(Self::Aspt1),
            "ASPt2" => Ok(Self::Aspt2),
            "AUDT2" => Ok(Self::Audt2),
            "AVld1" => Ok(Self::Avld1),
            "AmbT1" => Ok(Self::Ambt1),
            "AsyC1" => Ok(Self::Asyc1),
            "AsyN1" => Ok(Self::Asyn1),
            "AsyV1" => Ok(Self::Asyv1),
            "B1Pt1" => Ok(Self::B1pt1),
            "B1Pt2" => Ok(Self::B1pt2),
            "BCTS1" => Ok(Self::Bcts1),
            "BcRn1" => Ok(Self::Bcrn1),
            "BcRs1" => Ok(Self::Bcrs1),
            "BcRs2" => Ok(Self::Bcrs2),
            "CAED1" => Ok(Self::Caed1),
            "CALt1" => Ok(Self::Calt1),
            "CARn1" => Ok(Self::Carn1),
            "CASN1" => Ok(Self::Casn1),
            "CBED1" => Ok(Self::Cbed1),
            "CBID1" => Ok(Self::Cbid1),
            "CBLt1" => Ok(Self::Cblt1),
            "CBRn1" => Ok(Self::Cbrn1),
            "CBTp1" => Ok(Self::Cbtp1),
            "CLRG1" => Ok(Self::Clrg1),
            "CLRG2" => Ok(Self::Clrg2),
            "CRLn1" => Ok(Self::Crln1),
            "CRLn2" => Ok(Self::Crln2),
            "CTOw1" => Ok(Self::Ctow1),
            "CkSm1" => Ok(Self::Cksm1),
            "DCEv1" => Ok(Self::Dcev1),
            "DCHT1" => Ok(Self::Dcht1),
            "DOEv1" => Ok(Self::Doev1),
            "ESig2" => Ok(Self::Esig2),
            "FTab1" => Ok(Self::Ftab1),
            "FVoc1" => Ok(Self::Fvoc1),
            "Feat1" => Ok(Self::Feat1),
            "HCFG1" => Ok(Self::Hcfg1),
            "HCFG2" => Ok(Self::Hcfg2),
            "HCFG3" => Ok(Self::Hcfg3),
            "HCFG4" => Ok(Self::Hcfg4),
            "InjN1" => Ok(Self::Injn1),
            "LAST1" => Ok(Self::Last1),
            "NOIS1" => Ok(Self::Nois1),
            "P1AM1" => Ok(Self::P1am1),
            "P1RL1" => Ok(Self::P1rl1),
            "P1WD1" => Ok(Self::P1wd1),
            "P2AM1" => Ok(Self::P2am1),
            "P2BA1" => Ok(Self::P2ba1),
            "P2RL1" => Ok(Self::P2rl1),
            "PBAS1" => Ok(Self::Pbas1),
            "PBAS2" => Ok(Self::Pbas2),
            "PCON1" => Ok(Self::Pcon1),
            "PCON2" => Ok(Self::Pcon2),
            "PDMF2" => Ok(Self::Pdmf2),
            "PLOC1" => Ok(Self::Ploc1),
            "PLOC2" => Ok(Self::Ploc2),
            "PRJT1" => Ok(Self::Prjt1),
            "PROJ4" => Ok(Self::Proj4),
            "PSZE1" => Ok(Self::Psze1),
            "PTYP1" => Ok(Self::Ptyp1),
            "PuSc1" => Ok(Self::Pusc1),
            "QV201" => Ok(Self::Qv201),
            "QV202" => Ok(Self::Qv202),
            "QcPa1" => Ok(Self::Qcpa1),
            "QcRn1" => Ok(Self::Qcrn1),
            "QcRs1" => Ok(Self::Qcrs1),
            "QcRs2" => Ok(Self::Qcrs2),
            "RGOw1" => Ok(Self::Rgow1),
            "RInj1" => Ok(Self::Rinj1),
            "RNmF1" => Ok(Self::Rnmf1),
            "RevC1" => Ok(Self::Revc1),
            "RunN1" => Ok(Self::Runn1),
            "S/N%1" => Ok(Self::Sn1),
            "SMID1" => Ok(Self::Smid1),
            "SMRn1" => Ok(Self::Smrn1),
            "SPAC1" => Ok(Self::Spac1),
            "SPAC2" => Ok(Self::Spac2),
            "SPAC3" => Ok(Self::Spac3),
            "SPEC1" => Ok(Self::Spec1),
            "SVER2" => Ok(Self::Sver2),
            "SVER4" => Ok(Self::Sver4),
            "ScPa1" => Ok(Self::Scpa1),
            "ScSt1" => Ok(Self::Scst1),
            "SpeN1" => Ok(Self::Spen1),
            "TrPa1" => Ok(Self::Trpa1),
            "TrSc1" => Ok(Self::Trsc1),
            "TrSc2" => Ok(Self::Trsc2),
            "phAR1" => Ok(Self::Phar1),
            "phCH1" => Ok(Self::Phch1),
            "phDY1" => Ok(Self::Phdy1),
            "phQL1" => Ok(Self::Phql1),
            "phTR1" => Ok(Self::Phtr1),
            "phTR2" => Ok(Self::Phtr2),
            _ => Err(io::Error::new(
                ErrorKind::InvalidData,
                format!("Invalid tag string: {}", inp),
            )),
        }
    }
}

impl Display for Abi3530Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let str = match self {
            Self::Aact1 => "Primary Analysis Audit Active indication. True if system auditing was enabled during the last write of this file.",
            Self::Abed1 => "Anode buffer expiration date using ISO 8601 format.",
            Self::Abid1 => "Anode buffer tray first installed date.",
            Self::Ablt1 => "Anode buffer lot number.",
            Self::Abrn1 => "Number of runs processed with the current Anode Buffer (runs allowed - runs remaining).",
            Self::Abtp1 => "Anode buffer type.",
            Self::Aept1 => "Analysis Ending scan number for basecalling on initial analysis.",
            Self::Aept2 => "Analysis Ending scan number for basecalling on last analysis.",
            Self::Apcn1 => "Amplicon name.",
            Self::Artn1 => "Analysis Return code. Produced only by 5 Prime basecaller 1.0b3.",
            Self::Aspf1 => "Flag to indicate whether adaptive processing worked or not.",
            Self::Aspt1 => "Analysis Starting scan number for first analysis.",
            Self::Aspt2 => "Analysis Starting scan number for last analysis.",
            Self::Audt2 => "Audit log used across 3500 software.",
            Self::Avld1 => "Assay validation flag (true or false).",
            Self::Ambt1 => "Record of ambient temperature readings.",
            Self::Asyc1 => "The assay contents (XML format).",
            Self::Asyn1 => "The assay name.",
            Self::Asyv1 => "The assay version.",
            Self::B1pt1 => "Reference scan number for mobility and spacing curves for first analysis.",
            Self::B1pt2 => "Reference scan number for mobility and spacing curves for last analysis.",
            Self::Bcts1 => "Basecaller timestamp. Time of completion of most recent analysis.",
            Self::Bcrn1 => "Basecalling QC code.",
            Self::Bcrs1 => "Basecalling warnings, a concatenated comma-separated string.",
            Self::Bcrs2 => "Basecalling errors, a concatenated comma-separated string.",
            Self::Caed1 => "Capillary array expiration.",
            Self::Calt1 => "Capillary array lot number.",
            Self::Carn1 => "Number of injections processed through the capillary array.",
            Self::Casn1 => "Capillary array serial number.",
            Self::Cbed1 => "Cathode buffer expiration date.",
            Self::Cbid1 => "Cathode buffer tray first installed date.",
            Self::Cblt1 => "Cathode buffer lot number.",
            Self::Cbrn1 => "Number of runs processed with the current Cathode Buffer (runs allowed - runs remaining).",
            Self::Cbtp1 => "Cathode buffer type.",
            Self::Clrg1 => "Start of the clear range (inclusive).",
            Self::Clrg2 => "Clear range length.",
            Self::Crln1 => "Contiguous read length.",
            Self::Crln2 => "QC status: Pass, Fail, or Check.",
            Self::Ctow1 => "The name entered as the Owner of a plate in the plate editor.",
            Self::Cksm1 => "File checksum.",
            Self::Dcev1 => "A list of door-close events, separated by semicolon.",
            Self::Dcht1 => "Detection cell heater temperature setting from the Run Module.",
            Self::Doev1 => "A list of door-open events, separated by semicolon.",
            Self::Esig2 => "Electronic signature record used across 3500 software.",
            Self::Ftab1 => "Feature table created by Nibbler for Clear Range.",
            Self::Fvoc1 => "Feature table vocabulary created by Nibbler for Clear Range.",
            Self::Feat1 => "Features created by Nibbler for Clear Range.",
            Self::Hcfg1 => "The Instrument Class: CE.",
            Self::Hcfg2 => "The Instrument Family: 31XX, 35XX, or 37XX.",
            Self::Hcfg3 => "The official instrument name: e.g., 3130, 3130xl, 3730, 3730xl, 3500, 3500xl.",
            Self::Hcfg4 => "Instrument parameters: key-value pairs of instrument configuration information.",
            Self::Injn1 => "Injection name.",
            Self::Last1 => "Parameter settings information.",
            Self::Nois1 => "Estimate of RMS baseline noise for each dye.",
            Self::P1am1 => "Amplitude of primary peak.",
            Self::P1rl1 => "Deviation of primary peak position.",
            Self::P1wd1 => "Full-width half-max of primary peak.",
            Self::P2am1 => "Amplitude of secondary peak.",
            Self::P2ba1 => "Base of secondary peak.",
            Self::P2rl1 => "Deviation of secondary peak position.",
            Self::Pbas1 => "Array of sequence characters edited by user.",
            Self::Pbas2 => "Array of sequence characters as called by Basecaller.",
            Self::Pcon1 => "Array of quality values edited by user.",
            Self::Pcon2 => "Array of quality values as called by Basecaller.",
            Self::Pdmf2 => "Mobility file name chosen in most recent analysis.",
            Self::Ploc1 => "Array of peak locations edited by user.",
            Self::Ploc2 => "Array of peak locations as called by Basecaller.",
            Self::Prjt1 => "SeqScape project template name.",
            Self::Proj4 => "SeqScape project name.",
            Self::Psze1 => "Plate size: 96 or 384.",
            Self::Ptyp1 => "Plate type: 96-Well or 384-Well.",
            Self::Pusc1 => "Median pupscore.",
            Self::Qv201 => "QV20+ value.",
            Self::Qv202 => "QC status: Pass, Fail, or Check.",
            Self::Qcpa1 => "QC parameters.",
            Self::Qcrn1 => "Trimming and QC code.",
            Self::Qcrs1 => "QC warnings, a concatenated comma-separated string.",
            Self::Qcrs2 => "QC errors, a concatenated comma-separated string.",
            Self::Rgow1 => "Results group owner name.",
            Self::Rinj1 => "Reinjection number.",
            Self::Rnmf1 => "Raman normalization factor.",
            Self::Revc1 => "Whether the sequence has been complemented.",
            Self::Runn1 => "Run name (different from injection name on 3500).",
            Self::Sn1 => "Signal strength for each dye.",
            Self::Smid1 => "Polymer first installed date.",
            Self::Smrn1 => "Number of runs processed with the current polymer.",
            Self::Spac1 => "Average peak spacing used in last analysis.",
            Self::Spac2 => "Basecaller name.",
            Self::Spac3 => "Average peak spacing calculated by the Basecaller.",
            Self::Spec1 => "Sequencing Analysis Specimen Name.",
            Self::Sver2 => "Basecaller version number.",
            Self::Sver4 => "Sample File Format Version String.",
            Self::Scpa1 => "Size caller parameter string.",
            Self::Scst1 => "Raw data start point.",
            Self::Spen1 => "Active spectral calibration name.",
            Self::Trpa1 => "Trimming parameters.",
            Self::Trsc1 => "Trace score.",
            Self::Trsc2 => "QC status: Pass, Fail, or Check.",
            Self::Phar1 => "Trace peak area ratio.",
            Self::Phch1 => "Chemistry type based on DYE_1 information.",
            Self::Phdy1 => "Dye information.",
            Self::Phql1 => "Maximum Quality Value.",
            Self::Phtr1 => "Trim region set.",
            Self::Phtr2 => "Trim probability.",
        }
            .to_string();
        write!(f, "{}", str)
    }
}

#[derive(Clone, Copy, PartialEq)]
enum Abi3730Tag {
    Buft1,
}

impl Abi3730Tag {
    fn from_str(inp: &str) -> io::Result<Self> {
        match inp {
            "BufT1" => Ok(Self::Buft1),
            _ => Err(io::Error::new(
                ErrorKind::InvalidData,
                format!("Invalid tag string: {}", inp),
            )),
        }
    }
}

impl Display for Abi3730Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let str = match self {
            Self::Buft1 => "Buffer tray heater temperature (degrees C)",
        }
        .to_string();
        write!(f, "{}", str)
    }
}
